var J=Object.defineProperty;var a=(e,s)=>J(e,"name",{value:s,configurable:!0});import{r as Q}from"./get-pipe-path-BHW2eJdv.mjs";import d from"node:module";import u from"node:path";import{fileURLToPath as T}from"node:url";import{parseTsconfig as k,getTsconfig as z,createFilesMatcher as B,createPathsMatcher as G}from"get-tsconfig";import H from"node:fs";import{b as X,i as K,a as V}from"./index-BQiEz0On.mjs";import{p as v}from"./client-BQVF1NaW.mjs";const Y=[".js",".json",".ts",".tsx",".jsx"],x=Object.create(null);x[".js"]=[".ts",".tsx",".js",".jsx"],x[".jsx"]=[".tsx",".ts",".jsx",".js"],x[".cjs"]=[".cts"],x[".mjs"]=[".mts"];const M=a((e,s)=>{const t=e.split("?");let[n]=t;const r=u.extname(n);let o=x[r];if(o)n=n.slice(0,-r.length);else{if(!s)return;o=Y}return o.map(c=>n+c+(t[1]?`?${t[1]}`:""))},"mapTsExtensions"),Z=a(e=>{const s=e.indexOf(":");if(s!==-1)return e.slice(0,s)},"getScheme"),R=a(e=>e[0]==="."&&(e[1]==="/"||e[1]==="."||e[2]==="/"),"isRelativePath"),q=a(e=>R(e)||u.isAbsolute(e),"isUnixPath"),ee=a(e=>{if(q(e))return!0;const s=Z(e);return s&&s!=="node"},"requestAcceptsQuery"),U="file://",L=/\.([cm]?ts|[tj]sx)($|\?)/,se=/\.json($|\?)/,te=/\/(?:$|\?)/,$=/^(?:@[^/]+\/)?[^/\\]+$/;let j,y,O=!1;const D=a(e=>{let s=null;if(e){const t=u.resolve(e);s={path:t,config:k(t)}}else{try{s=z()}catch{}if(!s)return}j=B(s),y=G(s),O=s?.config.compilerOptions?.allowJs??!1},"loadTsconfig"),E=a(e=>Array.from(e).length>0?`?${e.toString()}`:"","urlSearchParamsStringify"),F=[".ts",".tsx",".jsx"],A=a((e,...s)=>{for(const t of F){const n=s.slice();n[0]+=t;try{return e(...n)}catch{}}},"tryExtensions"),ne=a(e=>(s,...t)=>{try{return e(s,...t)}catch(n){const r=n;if(r.code==="MODULE_NOT_FOUND"&&!$.test(s)){const o=A(e,s,...t)||A(e,`${s}${u.sep}index`,...t);if(o)return o}throw r}},"createImplicitResolver"),re=`${u.sep}node_modules${u.sep}`,N=a(e=>{if(!e.startsWith("data:text/javascript,"))return;const s=e.indexOf("?");if(s===-1)return;const n=new URLSearchParams(e.slice(s+1)).get("filePath");if(n)return n},"getOriginalFilePath"),W=a(e=>{const s=N(e);return s&&(d._cache[s]=d._cache[e],delete d._cache[e],e=s),e},"interopCjsExports"),b=a((e,s,t)=>{if(!(t?.filename&&L.test(t.filename))&&!O)return;const n=M(s);if(n)for(const r of n)try{return e(r)}catch(o){const{code:c}=o;if(c!=="MODULE_NOT_FOUND"&&c!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw o}},"resolveTsFilename"),oe=a((e,s,t)=>{if(e.startsWith(U)&&(e=T(e)),y&&!R(e)&&!s?.filename?.includes(re)){const r=y(e);for(const o of r){const c=b(t,o,s);if(c)return c;try{return t(o)}catch{}}}const n=b(t,e,s);if(n)return n;try{return t(e)}catch(r){const o=r;if(o.code==="MODULE_NOT_FOUND"&&typeof o.path=="string"&&o.path.endsWith(`${u.sep}package.json`)){const c=o.message.match(/^Cannot find module '([^']+)'$/);if(c){const p=c[1],f=b(t,p,s);if(f)return f}const i=o.message.match(/^Cannot find module '([^']+)'. Please verify that the package.json has a valid "main" entry$/);if(i){const p=i[1],f=b(t,p,s);if(f)return f}}throw o}},"resolveRequest"),ae=a((e,s)=>(t,n,r,o)=>{const c=a(m=>e(m,n,r,o),"resolve");if(t=W(t),n?.filename){const m=N(n.filename);m&&(n.filename=m.split("?")[0])}const i=t.split("?"),p=new URLSearchParams(i[1]);if(n?.filename){const P=new URLSearchParams(n.filename.split("?")[1]).get("namespace");P&&p.append("namespace",P)}if((p.get("namespace")??void 0)!==s)return c(t);s&&(e=ne(e));let f=oe(i[0],n,c);return u.isAbsolute(f)&&!f.endsWith(".json")&&!f.endsWith(".node")&&(f+=E(p)),f},"createResolveFilename"),ce=`
//# sourceMappingURL=data:application/json;base64,`,C=a(()=>process.sourceMapsEnabled??!0,"shouldApplySourceMap"),_=a(({code:e,map:s})=>e+ce+Buffer.from(JSON.stringify(s),"utf8").toString("base64"),"inlineSourceMap"),ie=[".cts",".mts",".ts",".tsx",".jsx"],fe=[".js",".cjs",".mjs"],le=a(e=>{const s=Object.create(Object.getPrototypeOf(e)),t=Object.getOwnPropertyDescriptors(e);for(const n in t)Object.hasOwn(t,n)&&Object.defineProperty(s,n,t[n]);return s},"cloneExtensions"),w=a((e,s,t,n)=>{const r=Object.getOwnPropertyDescriptor(e,s);r?.set?e[s]=t:(!r||r.configurable)&&Object.defineProperty(e,s,{value:t,enumerable:r?.enumerable||n?.enumerable,writable:n?.writable??(r?r.writable:!0),configurable:n?.configurable??(r?r.configurable:!0)})},"safeSet"),me=a((e,s)=>{const t=le(e),n=t[".js"],r=a((o,c)=>{const[i,p]=c.split("?");if((new URLSearchParams(p).get("namespace")??void 0)!==s)return n(o,i);v?.send&&v.send({type:"dependency",path:i});const m=ie.some(l=>i.endsWith(l)),P=fe.some(l=>i.endsWith(l));if(!m&&!P)return n(o,i);let h=H.readFileSync(i,"utf8");if(i.endsWith(".cjs")){const l=X(c,h);l&&(h=C()?_(l):l.code)}else if(m||K(h)){const l=V(h,c,{tsconfigRaw:j?.(i)});h=C()?_(l):l.code}o._compile(h,i)},"transformer");w(t,".js",r);for(const o of F)w(t,o,r,{enumerable:!s,writable:!0,configurable:!0});return w(t,".mjs",r,{writable:!0,configurable:!0}),t},"createExtensions"),I=a((e,s)=>{if(!s)throw new Error("The current file path (__filename or import.meta.url) must be provided in the second argument of tsx.require()");return(typeof s=="string"&&s.startsWith("file://")||s instanceof URL)&&(s=T(s)),u.resolve(u.dirname(s),e)},"resolveContext"),pe=a(e=>{const{sourceMapsEnabled:s}=process,{_extensions:t,_resolveFilename:n}=d;D(process.env.TSX_TSCONFIG_PATH),process.setSourceMapsEnabled(!0);const r=ae(n,e?.namespace);d._resolveFilename=r;const o=me(d._extensions,e?.namespace);d._extensions=o;const c=a(()=>{s===!1&&process.setSourceMapsEnabled(!1),d._extensions=t,d._resolveFilename=n},"unregister");if(e?.namespace){const i=a((f,m)=>{const P=I(f,m),[h,l]=P.split("?"),g=new URLSearchParams(l);return e.namespace&&g.set("namespace",e.namespace),Q(h+E(g))},"scopedRequire");c.require=i;const p=a((f,m,P)=>{const h=I(f,m),[l,g]=h.split("?"),S=new URLSearchParams(g);return e.namespace&&S.set("namespace",e.namespace),r(l+E(S),module,!1,P)},"scopedResolve");c.resolve=p,c.unregister=c}return c},"register");export{se as a,_ as b,U as c,ee as d,te as e,j as f,y as g,O as h,W as i,$ as j,D as l,M as m,pe as r,L as t};
